# Descripción del Proyecto: Backend MCP (Model context protocol)

## 1. Introducción y Objetivo

Este documento describe el diseño y plan de implementación para un servidor backend, denominado MCP (Servidor de Control Principal). El objetivo principal de este servidor es actuar como una interfaz robusta y segura entre un agente de Inteligencia Artificial (IA) y una base de datos PostgreSQL.

El sistema gestionará información relacionada con tareas de construcción o mantenimiento (inicialmente enfocado en pintura), incluyendo la estructura jerárquica de las obras, la definición detallada y polimórfica de los locales de trabajo, la asignación de tareas, la gestión de responsables (incluyendo equipos con distribución porcentual) y la asociación de precios a combinaciones específicas de tarea y local.

La IA interactuará exclusivamente con la API expuesta por el backend MCP, la cual abstraerá la complejidad de la base de datos y aplicará la lógica de negocio necesaria.

## 2. Requisitos Iniciales

Basado en las discusiones previas, los requisitos funcionales iniciales incluyen:

* **Gestión Jerárquica:** Poder definir y consultar la estructura de Obras -> Módulos -> Blocos -> Pavimentos -> Apartamentos.
* **Gestión de Locais (Polimórfica):**
    * Definir una tabla base `locais` con información común.
    * Soportar múltiples tipos específicos de locales (definidos en `tipo_local_enum`), cada uno con sus atributos particulares:
        * `AMBIENTE_INTERNO_APARTAMENTO` (con `apartamento_id`, `nome_ambiente`)
        * `APARTAMENTO` (referencia al apartamento como un todo, con `apartamento_id`)
        * `AREA_COMUM_INTERNA_BLOCO` (con `bloco_id`, `nome_area`)
        * `AREA_COMUM_FACHADA_BLOCO` (con `bloco_id`, `pano_vertical`, `pavimento_referencia`)
        * `AREA_COMUM_EXTERNA_BLOCO` (con `bloco_id`, `nome_area`)
        * `AREA_COMUM_MODULO` (con `modulo_id`, `nome_area`)
        * `RUA` (con `nome_rua`)
* **Gestión de Tipos de Tarefas:** Definir y gestionar los diferentes tipos de tareas que se pueden realizar (ej: 'Massa e 1º demão', '2ª Demão').
* **Gestión de Responsáveis:** Almacenar información de los trabajadores/responsables.
* **Gestión de Tarefas:**
    * Crear, leer, actualizar y eliminar tarefas.
    * Asociar cada tarefa a un `local` específico (referenciando `locais.id`).
    * Asociar cada tarefa a un `tipos_tarefa` específico.
    * **Múltiples Responsáveis por Tarefa:** Permitir asignar uno o más responsáveis a una única tarefa.
    * **Distribución de Responsabilidad:** Para cada responsável asignado a una tarefa, almacenar un porcentaje de responsabilidad.
    * **Validación de Suma 100%:** Asegurar (preferiblemente a nivel de base de datos con triggers) que la suma de los porcentajes de los responsáveis para una tarefa específica sea siempre 100%.
    * **Responsável Principal:** Indicar cuál de los responsáveis asignados es el principal.
* **Gestión de Precios:**
    * Definir precios estándar basados en la combinación de `tipos_tarefa` y `local`.
    * Asociar una tarefa a un registro de precio estándar aplicable en el momento de su creación/precificación.
* **Interacción con IA:** Proveer una API RESTful clara y bien documentada para que un agente de IA pueda realizar todas las operaciones anteriores. La API debe manejar la complejidad interna.

## 3. Resumen del Esquema y Datos de la Base de Datos (PostgreSQL)

*Basado en el dump `archivo.sql` proporcionado.*

```txt
# Resumen del Esquema y Datos Muestra de la Base de Datos PostgreSQL (Schema: public) para Referencia de LLM (Actualizado)

## ENUM Types

### public.tipo_local_enum
- Define los tipos válidos para la columna `tipo_local` en la tabla `locais`.
- Valores Posibles:
  - 'AMBIENTE_INTERNO_APARTAMENTO'
  - 'AREA_COMUM_INTERNA_BLOCO'
  - 'AREA_COMUM_FACHADA_BLOCO'
  - 'AREA_COMUM_EXTERNA_BLOCO'
  - 'AREA_COMUM_MODULO'
  - 'RUA'
  - 'APARTAMENTO'

## Estructura Jerárquica Principal y Datos Muestra

### public.obras
- Representa las obras o proyectos principales.
- **Columnas:**
  - `obra_id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único de la obra.
  - `nome` (TEXT, NOT NULL) - Nombre de la obra.
- **Datos:**
  - (1, 'ML1')
  - (2, 'ML2')

### public.modulos
- Representa los módulos dentro de una obra.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del módulo.
  - `nome` (TEXT, NOT NULL) - Nombre del módulo.
  - `obra_id` (BIGINT, FK -> obras.obra_id, NOT NULL) - ID de la obra a la que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `modulos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_obra_nome` (UNIQUE(obra_id, nome)) - Nombre del módulo debe ser único dentro de la obra.
- **Datos:**
  - (1, '01', 2)
  - (2, '02', 2)
  - (3, '03', 2)
  - (4, '04', 2)
  - (5, '05', 2)
  - (6, '06', 2)

### public.blocos
- Representa los bloques dentro de un módulo.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del bloco.
  - `nome` (TEXT, NOT NULL) - Nombre del bloco.
  - `modulo_id` (BIGINT, FK -> modulos.id, NOT NULL) - ID del módulo al que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `blocos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_modulo_nome` (UNIQUE(modulo_id, nome)) - Nombre del bloco debe ser único dentro del módulo.
- **Datos (Muestra):**
  - (1, '01', 6)
  - (2, '02', 6)
  - (...90 registros en total)
  - (70, '70', 4) -- Asumiendo Módulo 4 existe
  - (90, '90', 3)

### public.pavimentos
- Representa los pisos o pavimentos dentro de un bloco.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del pavimento.
  - `nome` (TEXT, NOT NULL) - Nombre/Número del pavimento (ej: 'Térreo', '01', '02').
  - `bloco_id` (BIGINT, FK -> blocos.id, NOT NULL) - ID del bloco al que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `pavimentos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_bloco_nome` (UNIQUE(bloco_id, nome)) - Nombre del pavimento debe ser único dentro del bloco.
- **Datos (Muestra):**
  - (1, '01', 1)
  - (2, '02', 1)
  - (...360 registros en total)
  - (360, '04', 90)

### public.apartamentos
- Representa los apartamentos o unidades dentro de un pavimento.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del apartamento.
  - `nome` (TEXT, NOT NULL) - Nombre/Número del apartamento (ej: '101', '205B').
  - `pavimento_id` (BIGINT, FK -> pavimentos.id, NOT NULL) - ID del pavimento al que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `apartamentos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_pavimento_nome` (UNIQUE(pavimento_id, nome)) - Nombre del apartamento debe ser único dentro del pavimento.
- **Datos (Muestra):**
  - (1, '101', 1)
  - (2, '102', 1)
  - (...1440 registros en total)
  - (1113, '301', 281) -- Apto 301, Bloco 70, Pav 03 (ID 281)
  - (1440, '404', 360)

## Estructura de Locais (Polimórfica) y Datos Muestra

### public.locais (Tabla Base)
- Tabla central para todas las ubicaciones. Contiene datos comunes.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único para CUALQUIER tipo de local.
  - `tipo_local` (public.tipo_local_enum, NOT NULL) - **Discriminador**. Indica qué tabla específica contiene los detalles.
  - `nome_display` (VARCHAR(350), NOT NULL) - Nombre descriptivo completo para mostrar.
  - `obra_id` (BIGINT, FK -> obras.obra_id, NOT NULL, ON DELETE RESTRICT) - ID de la obra a la que pertenece el local.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `locais`, pero se asume por consistencia. Si no existe, ignorar).
- **Datos:**
  - (17, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 101', 2)
  - (18, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 102', 2)
  - (19, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 103', 2)
  - (20, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 104', 2)
  - (25, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 301', 2)
  - (26, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 302', 2)
  - (27, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 303', 2)
  - (28, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 304', 2)
  - (29, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 401', 2)
  - (30, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 402', 2)
  - (31, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 403', 2)
  - (32, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 404', 2)
  - (Nota: Los locales 21-24 del dump original tenían tipo APARTAMENTO pero no tenían entrada en local_apartamento. Se listan aquí como referencia, pero pueden requerir corrección en los datos reales).

### public.local_ambiente_interno_apartamento (Tipo Específico)
- Detalles para locales de tipo 'AMBIENTE_INTERNO_APARTAMENTO'.
- **Columnas:**
  - `local_id` (BIGINT, PK, FK -> locais.id, ON DELETE CASCADE)
  - `apartamento_id` (BIGINT, FK -> apartamentos.id, NOT NULL, ON DELETE CASCADE)
  - `nome_ambiente` (VARCHAR(150), NOT NULL)
- **Datos:**
  - (17, 1105, 'Apartamento Completo')
  - (18, 1106, 'Apartamento Completo')
  - (19, 1107, 'Apartamento Completo')
  - (20, 1108, 'Apartamento Completo')

### public.local_apartamento (Tipo Específico)
- Detalles para locales de tipo 'APARTAMENTO'.
- **Columnas:**
  - `local_id` (BIGINT, PK, FK -> locais.id, ON DELETE CASCADE)
  - `apartamento_id` (BIGINT, FK -> apartamentos.id, NOT NULL, ON DELETE CASCADE)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `local_apartamento`, pero se asume por consistencia. Si no existe, ignorar).
- **Datos:**
  - (25, 1113)
  - (26, 1114)
  - (27, 1115)
  - (28, 1116)
  - (29, 1117)
  - (30, 1118)
  - (31, 1119)
  - (32, 1120)

### (Otras tablas `local_...` específicas)
- `local_area_comum_interna_bloco`, `local_area_comum_fachada_bloco`, `local_area_comum_externa_bloco`, `local_area_comum_modulo`, `local_rua`.
- **Datos:** (Vacias según el dump)

## Otras Tablas Principales y Datos Muestra

### public.tipos_tarefas
- Define los diferentes tipos de tareas que se pueden realizar.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `nome` (VARCHAR(255), NOT NULL, UNIQUE)
  - `funcao` (TEXT, NULL)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `tipos_tarefas`, pero se asume por consistencia. Si no existe, ignorar).
- **Datos:**
  - (1, 'Massa e 1º demão', 'PINTOR')
  - (2, '2ª Demão', 'PINTOR')

### public.responsaveis
- Almacena información sobre los trabajadores o responsables.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `nome` (TEXT, NOT NULL, UNIQUE)
  - `matricula` (NUMERIC, NULL)
  - `funcao` (TEXT, NULL)
  - `data_admissao` (DATE, NULL)
  - `situacao` (TEXT, NULL)
  - `salario_categoria` (NUMERIC, NULL)
  - `obra_id` (BIGINT, FK -> obras.obra_id, NULL)
- **Datos (Muestra):**
  - (61, 'ADEMIR ALVES FILHO', 741, 'PINTOR', '2025-04-14', 'Ativo', 1821.64, 2)
  - (62, 'ALBERI DANTAS DA SILVA', 193, 'GESSEIRO', '2022-05-02', 'Ativo', 1821.64, 2)
  - (...186 registros en total)
  - (246, 'WERBSON NUNES XAVIER', 161, 'MONT. ANDAIMES', '2021-11-17', 'Afastado', 1821.64, 2)

### public.precos_tarefa_local
- Almacena los precios estándar para una combinación de tipo de tarefa y local.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `tipos_tarefa_id` (BIGINT, FK -> tipos_tarefas.id, NOT NULL, ON DELETE CASCADE)
  - `local_id` (BIGINT, FK -> locais.id, NOT NULL, ON DELETE CASCADE)
  - `preco` (NUMERIC(12, 2), NOT NULL, CHECK preco >= 0)
  - `unidade_medida` (VARCHAR(50), NULL)
  - `validade_inicio` (DATE, NULL, DEFAULT CURRENT_DATE)
  - `validade_fim` (DATE, NULL)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now())
- **Constraints:**
  - `uq_preco_tipo_local_unidade` (UNIQUE(tipos_tarefa_id, local_id, unidade_medida))
- **Datos:** (Vacía según el dump)

### public.tarefas
- Tabla principal que registra las tareas a realizar.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `nome` (TEXT, NOT NULL)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now())
  - `inicio` (DATE, NULL)
  - `fim` (DATE, NULL)
  - `local_id` (BIGINT, FK -> locais.id, NULL, ON DELETE SET NULL)
  - `tipos_tarefa_id` (BIGINT, FK -> tipos_tarefas.id, NULL, ON DELETE SET NULL)
  - `preco_tarefa_local_id` (BIGINT, FK -> precos_tarefa_local.id, NULL, ON DELETE SET NULL)
- **Datos:** (Vacía según el dump)

## Tablas de Relación (Many-to-Many) y Datos Muestra

### public.tarefa_responsaveis
- Tabla de junção que conecta tarefas com seus múltiplos responsáveis e armazena detalhes da atribuição.
- **Columnas:**
  - `tarefa_id` (BIGINT, PK part, FK -> tarefas.id, NOT NULL, ON DELETE CASCADE)
  - `responsavel_id` (BIGINT, PK part, FK -> responsaveis.id, NOT NULL, ON DELETE CASCADE)
  - `percentual` (NUMERIC(5, 2), NOT NULL, DEFAULT 100.00, CHECK > 0 AND <= 100.00)
  - `eh_principal` (BOOLEAN, NOT NULL, DEFAULT FALSE)
- **Constraints:**
  - `tarefa_responsaveis_pkey` (PRIMARY KEY(tarefa_id, responsavel_id))
- **Nota:** A validação da soma dos `percentual` para 100% por `tarefa_id` é feita por Trigger.
- **Datos:** (Vacía según el dump)

## Funciones y Triggers Notables

- `public.checar_soma_100_tarefa(BIGINT)`: Función que verifica si la suma de `percentual` en `tarefa_responsaveis` es 100 para una `tarefa_id` dada.
- `public.trigger_checar_soma_100_tarefa()`: Función de Trigger que llama a la función de verificación.
- `trig_checar_soma_100` en `tarefa_responsaveis`: CONSTRAINT TRIGGER que usa las funciones anteriores para forzar la suma de 100% no `COMMIT` da transação.
- `public.sum_function(integer, integer)`: Función de ejemplo (no parece estar directamente relacionada con el esquema principal de negocio).

## Resumen de Relaciones Clave para Consultas

- **Jerarquía:** `obras` -> `modulos` -> `blocos` -> `pavimentos` -> `apartamentos`.
- **Localización:**
  - `tarefas.local_id` -> `locais.id` (Obtiene información común del local y el `tipo_local`).
  - Dependiendo de `locais.tipo_local`, hacer JOIN con la tabla específica correspondiente (`local_ambiente_interno_apartamento`, `local_apartamento`, `local_rua`, etc.) usando `locais.id = tabla_especifica.local_id`.
  - Para obtener la jerarquía completa de un local, hacer JOIN desde `locais.obra_id` y/o desde las FKs nas tabelas específicas (`apartamento_id`, `bloco_id`, `modulo_id`).
- **Responsables:**
  - `tarefas` -> `tarefa_responsaveis` (JOIN en `tarefas.id = tarefa_responsaveis.tarefa_id`).
  - `tarefa_responsaveis` -> `responsaveis` (JOIN en `tarefa_responsaveis.responsavel_id = responsaveis.id`).
- **Tipo de Tarefa:** `tarefas.tipos_tarefa_id` -> `tipos_tarefas.id`.
- **Precio Estándar:** `tarefas.preco_tarefa_local_id` -> `precos_tarefa_local.id`. Para obtener los detalles del precio (tipo y local a los que se aplica), hacer JOIN adicional desde `precos_tarefa_local` para `tipos_tarefas` y `locais`.

```

## 4. Arquitectura Backend Sugerida

* **Objetivo:** Exponer API segura, abstraer complejidad de DB, implementar lógica de negocio, garantizar integridad.
* **Tecnologías:**
    * Lenguaje: Python 3.x
    * Framework API: FastAPI
    * ORM y Validación: SQLModel (basado en SQLAlchemy y Pydantic)
    * Base de Datos: PostgreSQL
    * Migraciones: Alembic
    * Servidor ASGI: Uvicorn (+ Gunicorn en producción)
* **Capas Lógicas:**
    * **Capa API (FastAPI):** Endpoints HTTP, validación/serialización con Pydantic/SQLModel, autenticación/autorización, delegación a servicios.
    * **Capa Lógica de Negocio (Servicios):** Orquestación, validaciones de negocio, interacción con capa de datos.
    * **Capa Acceso a Datos (SQLModel):** Modelos de datos (mapeo a DB), interacción con DB vía sesiones SQLAlchemy, manejo de polimorfismo.
    * **Base de Datos (PostgreSQL):** Almacenamiento persistente, ejecución de constraints y triggers.
* **Consideraciones:** Autenticación (OAuth2/JWT), manejo de errores, logging, pruebas (unitarias y de integración), despliegue (Docker, Cloud/PaaS), documentación API (OpenAPI).

## 5. Plan de Trabajo Sugerido

* **Fase 1: Configuración Inicial y Fundación (Setup):** Estructura de proyecto, entorno virtual, dependencias, configuración (`.env`), conexión a DB (engine SQLModel), app FastAPI básica.
* **Fase 2: Generación de Modelos y Configuración de Migraciones:** Generar modelos SQLModel desde DB (con `sqlacodegen`), adaptar manualmente (herencia, relaciones, `Field`), inicializar y configurar Alembic, generar y estampar migración inicial (baseline).
* **Fase 3: Endpoints CRUD para Entidades Simples:** Implementar API, servicios y acceso a datos para entidades como `Obras`, `Modulos`, `Responsaveis`, `TiposTarefas`.
* **Fase 4: Implementación del Polimorfismo (Locais):** Definir modelos API con uniones discriminadas, implementar servicios y endpoints CRUD para `Locais` manejando la creación/lectura de tipos específicos.
* **Fase 5: Implementación Many-to-Many (Tarefas y Responsaveis):** Definir modelos API para creación/lectura de `Tarefas` (incluyendo lista de responsáveis), implementar servicios (validación suma 100%, `eh_principal`), endpoints CRUD para `Tarefas`.
* **Fase 6: Implementación de Lógica de Precios:** Implementar CRUD para `PrecosTarefaLocal`, añadir lógica en servicio `Tarefas` para buscar y asignar `preco_tarefa_local_id`.
* **Fase 7: Lógica de Negocio Adicional y Validaciones Avanzadas:** Implementar reglas de negocio específicas y validaciones robustas.
* **Fase 8: Autenticación y Autorización:** Implementar seguridad (OAuth2/JWT), proteger endpoints.
* **Fase 9: Pruebas:** Escribir pruebas unitarias y de integración.
* **Fase 10: Documentación y Preparación para Despliegue:** Revisar OpenAPI, configurar logging, crear Dockerfile, preparar configuración de producción.

Este documento proporciona una visión general completa del proyecto, desde los requisitos hasta un plan de implementación detallado, sirviendo como una guía central para el desarrollo del backend MCP.

